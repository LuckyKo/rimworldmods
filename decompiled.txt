	public class InteractionWorker_Chitchat : InteractionWorker
	{
		public override float RandomSelectionWeight(Pawn initiator, Pawn recipient)
		{
			if (initiator.Inhumanized())
			{
				return 0f;
			}
			return 1f;
		}
	}

	public class JobGiver_GetJoy : ThinkNode_JobGiver
	{
		[Unsaved(false)]
		private DefMap<JoyGiverDef, float> joyGiverChances;

		private const float JoyBuffer = 0.99f;

		protected virtual bool CanDoDuringMedicalRest => false;

		protected virtual bool JoyGiverAllowed(JoyGiverDef def)
		{
			return true;
		}

		protected virtual Job TryGiveJobFromJoyGiverDefDirect(JoyGiverDef def, Pawn pawn)
		{
			return def.Worker.TryGiveJob(pawn);
		}

		public override void ResolveReferences()
		{
			joyGiverChances = new DefMap<JoyGiverDef, float>();
		}

		protected override Job TryGiveJob(Pawn pawn)
		{
			if (!CanDoDuringMedicalRest && pawn.InBed() && HealthAIUtility.ShouldSeekMedicalRest(pawn))
			{
				return null;
			}
			if (pawn.needs.joy.CurLevel >= 0.99f)
			{
				return null;
			}
			List<JoyGiverDef> allDefsListForReading = DefDatabase<JoyGiverDef>.AllDefsListForReading;
			JoyToleranceSet tolerances = pawn.needs.joy.tolerances;
			for (int i = 0; i < allDefsListForReading.Count; i++)
			{
				JoyGiverDef joyGiverDef = allDefsListForReading[i];
				joyGiverChances[joyGiverDef] = 0f;
				if (!JoyGiverAllowed(joyGiverDef) || pawn.needs.joy.tolerances.BoredOf(joyGiverDef.joyKind) || !joyGiverDef.Worker.CanBeGivenTo(pawn))
				{
					continue;
				}
				if (joyGiverDef.pctPawnsEverDo < 1f)
				{
					Rand.PushState(pawn.thingIDNumber ^ 0x3C49C49);
					if (Rand.Value >= joyGiverDef.pctPawnsEverDo)
					{
						Rand.PopState();
						continue;
					}
					Rand.PopState();
				}
				float num = tolerances[joyGiverDef.joyKind];
				float num2 = Mathf.Pow(1f - num, 5f);
				num2 = Mathf.Max(0.001f, num2);
				joyGiverChances[joyGiverDef] = joyGiverDef.Worker.GetChance(pawn) * num2;
			}
			for (int j = 0; j < joyGiverChances.Count; j++)
			{
				if (!allDefsListForReading.TryRandomElementByWeight((JoyGiverDef d) => joyGiverChances[d], out var result))
				{
					break;
				}
				Job job = TryGiveJobFromJoyGiverDefDirect(result, pawn);
				if (job != null)
				{
					return job;
				}
				joyGiverChances[result] = 0f;
			}
			return null;
		}
	}
	public class JobGiver_GetJoyInBed : JobGiver_GetJoy
	{
		private const float MaxJoyLevel = 0.5f;

		protected override bool CanDoDuringMedicalRest => true;

		protected override bool JoyGiverAllowed(JoyGiverDef def)
		{
			return def.canDoWhileInBed;
		}

		protected override Job TryGiveJobFromJoyGiverDefDirect(JoyGiverDef def, Pawn pawn)
		{
			return def.Worker.TryGiveJobWhileInBed(pawn);
		}

		protected override Job TryGiveJob(Pawn pawn)
		{
			if (pawn.CurJob == null || !pawn.InBed() || !pawn.Awake() || pawn.needs.joy == null)
			{
				return null;
			}
			if (pawn.health.hediffSet.InLabor())
			{
				return null;
			}
			if (pawn.needs.joy.CurLevel > 0.5f)
			{
				return null;
			}
			return base.TryGiveJob(pawn);
		}
	}
	public class JobGiver_IdleJoy : JobGiver_GetJoy
	{
		private const int GameStartNoIdleJoyTicks = 60000;

		protected override Job TryGiveJob(Pawn pawn)
		{
			if (pawn.needs.joy == null)
			{
				return null;
			}
			if (Find.TickManager.TicksGame < 60000)
			{
				return null;
			}
			if (JoyUtility.LordPreventsGettingJoy(pawn) || JoyUtility.TimetablePreventsGettingJoy(pawn))
			{
				return null;
			}
			return base.TryGiveJob(pawn);
		}
	}
	public abstract class JoyGiver
	{
		public JoyGiverDef def;

		public virtual float GetChance(Pawn pawn)
		{
			return def.baseChance;
		}

		protected virtual void GetSearchSet(Pawn pawn, List<Thing> outCandidates)
		{
			outCandidates.Clear();
			if (def.thingDefs == null)
			{
				return;
			}
			if (def.thingDefs.Count == 1)
			{
				outCandidates.AddRange(pawn.Map.listerThings.ThingsOfDef(def.thingDefs[0]));
			}
			else
			{
				for (int i = 0; i < def.thingDefs.Count; i++)
				{
					outCandidates.AddRange(pawn.Map.listerThings.ThingsOfDef(def.thingDefs[i]));
				}
			}
			if (pawn.ConcernedByVacuum)
			{
				outCandidates.RemoveWhere((Thing thing) => thing.Position.VacuumConcernTo(pawn));
			}
		}

		public abstract Job TryGiveJob(Pawn pawn);

		public virtual Job TryGiveJobWhileInBed(Pawn pawn)
		{
			return null;
		}

		public virtual Job TryGiveJobInGatheringArea(Pawn pawn, IntVec3 gatherSpot, float maxRadius = -1f)
		{
			return null;
		}

		public virtual bool CanBeGivenTo(Pawn pawn)
		{
			if (MissingRequiredCapacity(pawn) != null)
			{
				return false;
			}
			if (def.requiresEnjoyOutdoors && (!pawn.needs.PrefersOutdoors || (pawn.genes != null && !pawn.genes.EnjoysSunlight)))
			{
				return false;
			}
			return def.joyKind.PawnCanDo(pawn);
		}

		public PawnCapacityDef MissingRequiredCapacity(Pawn pawn)
		{
			for (int i = 0; i < def.requiredCapacities.Count; i++)
			{
				if (!pawn.health.capacities.CapableOf(def.requiredCapacities[i]))
				{
					return def.requiredCapacities[i];
				}
			}
			return null;
		}
	}
	public class JoyGiver_BuildSnowman : JoyGiver
	{
		private const float MinSnowmanDepth = 0.5f;

		private const float MinDistBetweenSnowmen = 12f;

		private const float MinSnowDepth = 200f;

		public override Job TryGiveJob(Pawn pawn)
		{
			if (pawn.WorkTypeIsDisabled(WorkTypeDefOf.Construction))
			{
				return null;
			}
			if (!JoyUtility.EnjoyableOutsideNow(pawn))
			{
				return null;
			}
			if (pawn.Map.snowGrid.TotalDepth < 200f)
			{
				return null;
			}
			IntVec3 intVec = TryFindSnowmanBuildCell(pawn);
			if (!intVec.IsValid)
			{
				return null;
			}
			return JobMaker.MakeJob(def.jobDef, intVec);
		}

		private static IntVec3 TryFindSnowmanBuildCell(Pawn pawn)
		{
			if (!CellFinder.TryFindClosestRegionWith(pawn.GetRegion(), TraverseParms.For(pawn), (Region r) => r.Room.PsychologicallyOutdoors, 100, out var rootReg))
			{
				return IntVec3.Invalid;
			}
			IntVec3 result = IntVec3.Invalid;
			RegionTraverser.BreadthFirstTraverse(rootReg, (Region from, Region region) => region.District == rootReg.District, delegate(Region region)
			{
				for (int i = 0; i < 5; i++)
				{
					IntVec3 randomCell = region.RandomCell;
					if (IsGoodSnowmanCell(randomCell, pawn))
					{
						result = randomCell;
						return true;
					}
				}
				return false;
			}, 30);
			return result;
		}

		private static bool IsGoodSnowmanCell(IntVec3 c, Pawn pawn)
		{
			if (pawn.Map.snowGrid.GetDepth(c) < 0.5f)
			{
				return false;
			}
			if (c.Fogged(pawn.Map))
			{
				return false;
			}
			if (c.GetEdifice(pawn.Map) != null)
			{
				return false;
			}
			if (c.IsForbidden(pawn))
			{
				return false;
			}
			for (int i = 0; i < 9; i++)
			{
				IntVec3 intVec = c + GenAdj.AdjacentCellsAndInside[i];
				if (!intVec.InBounds(pawn.Map))
				{
					return false;
				}
				if (!intVec.Standable(pawn.Map))
				{
					return false;
				}
				if (pawn.Map.reservationManager.IsReservedAndRespected(intVec, pawn))
				{
					return false;
				}
			}
			List<Thing> list = pawn.Map.listerThings.ThingsOfDef(ThingDefOf.Snowman);
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j].Position.InHorDistOf(c, 12f))
				{
					return false;
				}
			}
			return true;
		}
	}
	public class JoyGiver_GoForWalk : JoyGiver
	{
		public override Job TryGiveJob(Pawn pawn)
		{
			if (!JoyUtility.EnjoyableOutsideNow(pawn))
			{
				return null;
			}
			if (PawnUtility.WillSoonHaveBasicNeed(pawn))
			{
				return null;
			}
			if (!CellFinder.TryFindClosestRegionWith(pawn.GetRegion(), TraverseParms.For(pawn), RegionValidator, 100, out var result))
			{
				return null;
			}
			if (!result.TryFindRandomCellInRegionUnforbidden(pawn, CellValidator, out var result2))
			{
				return null;
			}
			if (!WalkPathFinder.TryFindWalkPath(pawn, result2, out var result3))
			{
				return null;
			}
			Job job = JobMaker.MakeJob(def.jobDef, result3[0]);
			job.targetQueueA = new List<LocalTargetInfo>();
			for (int i = 1; i < result3.Count; i++)
			{
				job.targetQueueA.Add(result3[i]);
			}
			job.locomotionUrgency = LocomotionUrgency.Walk;
			return job;
			bool CellValidator(IntVec3 x)
			{
				if (!PawnUtility.KnownDangerAt(x, pawn.Map, pawn) && !x.Fogged(pawn.Map) && !x.GetTerrain(pawn.Map).avoidWander && x.Standable(pawn.Map))
				{
					return !x.Roofed(pawn.Map);
				}
				return false;
			}
			bool RegionValidator(Region x)
			{
				IntVec3 result4;
				if (x.Room.PsychologicallyOutdoors && !x.IsForbiddenEntirely(pawn))
				{
					return x.TryFindRandomCellInRegionUnforbidden(pawn, CellValidator, out result4);
				}
				return false;
			}
		}
	}



	public class JobDriver_Lovin : JobDriver
	{
		private int ticksLeft;

		private TargetIndex PartnerInd = TargetIndex.A;

		private TargetIndex BedInd = TargetIndex.B;

		private const int TicksBetweenHeartMotes = 100;

		private static float PregnancyChance = 0.05f;

		private static readonly SimpleCurve LovinIntervalHoursFromAgeCurve = new SimpleCurve
		{
			new CurvePoint(16f, 1.5f),
			new CurvePoint(22f, 1.5f),
			new CurvePoint(30f, 4f),
			new CurvePoint(50f, 12f),
			new CurvePoint(75f, 36f)
		};

		private Pawn Partner => (Pawn)(Thing)job.GetTarget(PartnerInd);

		private Building_Bed Bed => (Building_Bed)(Thing)job.GetTarget(BedInd);

		public override void ExposeData()
		{
			base.ExposeData();
			Scribe_Values.Look(ref ticksLeft, "ticksLeft", 0);
		}

		public override bool TryMakePreToilReservations(bool errorOnFailed)
		{
			if (pawn.Reserve(Partner, job, 1, -1, null, errorOnFailed))
			{
				return pawn.Reserve(Bed, job, Bed.SleepingSlotsCount, 0, null, errorOnFailed);
			}
			return false;
		}

		public override bool CanBeginNowWhileLyingDown()
		{
			return JobInBedUtility.InBedOrRestSpotNow(pawn, job.GetTarget(BedInd));
		}

		protected override IEnumerable<Toil> MakeNewToils()
		{
			this.FailOnDespawnedOrNull(BedInd);
			this.FailOnDespawnedOrNull(PartnerInd);
			this.FailOn(() => !Partner.health.capacities.CanBeAwake);
			this.KeepLyingDown(BedInd);
			yield return Toils_Bed.ClaimBedIfNonMedical(BedInd);
			yield return Toils_Bed.GotoBed(BedInd);
			Toil toil = ToilMaker.MakeToil("MakeNewToils");
			toil.initAction = delegate
			{
				if (Partner.CurJob == null || Partner.CurJob.def != JobDefOf.Lovin)
				{
					Job newJob = JobMaker.MakeJob(JobDefOf.Lovin, pawn, Bed);
					Partner.jobs.StartJob(newJob, JobCondition.InterruptForced);
					ticksLeft = (int)(2500f * Mathf.Clamp(Rand.Range(0.1f, 1.1f), 0.1f, 2f));
					Find.HistoryEventsManager.RecordEvent(new HistoryEvent(HistoryEventDefOf.InitiatedLovin, pawn.Named(HistoryEventArgsNames.Doer)));
					if (InteractionWorker_RomanceAttempt.CanCreatePsychicBondBetween(pawn, Partner) && InteractionWorker_RomanceAttempt.TryCreatePsychicBondBetween(pawn, Partner) && (PawnUtility.ShouldSendNotificationAbout(pawn) || PawnUtility.ShouldSendNotificationAbout(Partner)))
					{
						Find.LetterStack.ReceiveLetter("LetterPsychicBondCreatedLovinLabel".Translate(), "LetterPsychicBondCreatedLovinText".Translate(pawn.Named("BONDPAWN"), Partner.Named("OTHERPAWN")), LetterDefOf.PositiveEvent, new LookTargets(pawn, Partner));
					}
				}
				else
				{
					ticksLeft = 9999999;
				}
			};
			toil.defaultCompleteMode = ToilCompleteMode.Instant;
			yield return toil;
			Toil toil2 = Toils_LayDown.LayDown(BedInd, hasBed: true, lookForOtherJobs: false, canSleep: false, gainRestAndHealth: false);
			toil2.FailOn(() => Partner.CurJob == null || Partner.CurJob.def != JobDefOf.Lovin);
			toil2.AddPreTickIntervalAction(delegate(int delta)
			{
				ticksLeft -= delta;
				if (ticksLeft <= 0)
				{
					ReadyForNextToil();
				}
				else if (pawn.IsHashIntervalTick(100, delta))
				{
					FleckMaker.ThrowMetaIcon(pawn.Position, pawn.Map, FleckDefOf.Heart);
				}
			});
			toil2.AddFinishAction(delegate
			{
				Thought_Memory thought_Memory = (Thought_Memory)ThoughtMaker.MakeThought(ThoughtDefOf.GotSomeLovin);
				if ((base.pawn.health != null && base.pawn.health.hediffSet != null && base.pawn.health.hediffSet.hediffs.Any((Hediff h) => h.def == HediffDefOf.LoveEnhancer)) || (Partner.health != null && Partner.health.hediffSet != null && Partner.health.hediffSet.hediffs.Any((Hediff h) => h.def == HediffDefOf.LoveEnhancer)))
				{
					thought_Memory.moodPowerFactor = 1.5f;
				}
				if (base.pawn.needs.mood != null)
				{
					base.pawn.needs.mood.thoughts.memories.TryGainMemory(thought_Memory, Partner);
				}
				Find.HistoryEventsManager.RecordEvent(new HistoryEvent(HistoryEventDefOf.GotLovin, base.pawn.Named(HistoryEventArgsNames.Doer)));
				HistoryEventDef def = (base.pawn.relations.DirectRelationExists(PawnRelationDefOf.Spouse, Partner) ? HistoryEventDefOf.GotLovin_Spouse : HistoryEventDefOf.GotLovin_NonSpouse);
				Find.HistoryEventsManager.RecordEvent(new HistoryEvent(def, base.pawn.Named(HistoryEventArgsNames.Doer)));
				base.pawn.mindState.canLovinTick = Find.TickManager.TicksGame + GenerateRandomMinTicksToNextLovin(base.pawn);
				if (ModsConfig.BiotechActive)
				{
					Pawn pawn = ((base.pawn.gender == Gender.Male) ? base.pawn : ((Partner.gender == Gender.Male) ? Partner : null));
					Pawn pawn2 = ((base.pawn.gender == Gender.Female) ? base.pawn : ((Partner.gender == Gender.Female) ? Partner : null));
					if (pawn != null && pawn2 != null && Rand.Chance(PregnancyChance * PregnancyUtility.PregnancyChanceForPartners(pawn2, pawn)))
					{
						bool success;
						GeneSet inheritedGeneSet = PregnancyUtility.GetInheritedGeneSet(pawn, pawn2, out success);
						if (success)
						{
							Hediff_Pregnant hediff_Pregnant = (Hediff_Pregnant)HediffMaker.MakeHediff(HediffDefOf.PregnantHuman, pawn2);
							hediff_Pregnant.SetParents(null, pawn, inheritedGeneSet);
							pawn2.health.AddHediff(hediff_Pregnant);
						}
						else if (PawnUtility.ShouldSendNotificationAbout(pawn) || PawnUtility.ShouldSendNotificationAbout(pawn2))
						{
							Messages.Message("MessagePregnancyFailed".Translate(pawn.Named("FATHER"), pawn2.Named("MOTHER")) + ": " + "CombinedGenesExceedMetabolismLimits".Translate(), new LookTargets(pawn, pawn2), MessageTypeDefOf.NegativeEvent);
						}
					}
				}
			});
			toil2.socialMode = RandomSocialMode.Off;
			yield return toil2;
		}

		private int GenerateRandomMinTicksToNextLovin(Pawn pawn)
		{
			if (DebugSettings.alwaysDoLovin)
			{
				return 100;
			}
			float num = LovinIntervalHoursFromAgeCurve.Evaluate(pawn.ageTracker.AgeBiologicalYearsFloat);
			if (ModsConfig.BiotechActive && pawn.genes != null)
			{
				foreach (Gene item in pawn.genes.GenesListForReading)
				{
					num *= item.def.lovinMTBFactor;
				}
			}
			foreach (Hediff hediff in pawn.health.hediffSet.hediffs)
			{
				HediffComp_GiveLovinMTBFactor hediffComp_GiveLovinMTBFactor = hediff.TryGetComp<HediffComp_GiveLovinMTBFactor>();
				if (hediffComp_GiveLovinMTBFactor != null)
				{
					num *= hediffComp_GiveLovinMTBFactor.Props.lovinMTBFactor;
				}
			}
			num = Rand.Gaussian(num, 0.3f);
			if (num < 0.5f)
			{
				num = 0.5f;
			}
			return (int)(num * 2500f);
		}
	}