	public enum JobCondition : byte
	{
		None = 0,
		Ongoing = 1,
		Succeeded = 2,
		Incompletable = 4,
		InterruptOptional = 8,
		InterruptForced = 0x10,
		QueuedNoLongerValid = 0x20,
		Errored = 0x40,
		ErroredPather = 0x80
	}


	public static class Toils_Misc
	{
		public static Toil Learn(SkillDef skill, float xp)
		{
			Toil toil = ToilMaker.MakeToil("Learn");
			toil.initAction = delegate
			{
				toil.actor.skills.Learn(skill, xp);
			};
			return toil;
		}

		public static Toil SetForbidden(TargetIndex ind, bool forbidden)
		{
			Toil toil = ToilMaker.MakeToil("SetForbidden");
			toil.initAction = delegate
			{
				toil.actor.CurJob.GetTarget(ind).Thing.SetForbidden(forbidden);
			};
			return toil;
		}

		public static Toil TakeItemFromInventoryToCarrier(Pawn pawn, TargetIndex itemInd)
		{
			Toil toil = ToilMaker.MakeToil("TakeItemFromInventoryToCarrier");
			toil.initAction = delegate
			{
				Job curJob = pawn.CurJob;
				Thing thing = (Thing)curJob.GetTarget(itemInd);
				int count = Mathf.Min(thing.stackCount, curJob.count);
				pawn.inventory.innerContainer.TryTransferToContainer(thing, pawn.carryTracker.innerContainer, count);
				curJob.SetTarget(itemInd, pawn.carryTracker.CarriedThing);
			};
			return toil;
		}

		public static Toil ThrowColonistAttackingMote(TargetIndex target)
		{
			Toil toil = ToilMaker.MakeToil("ThrowColonistAttackingMote");
			toil.initAction = delegate
			{
				Pawn actor = toil.actor;
				Job curJob = actor.CurJob;
				if (actor.playerSettings != null && actor.playerSettings.UsesConfigurableHostilityResponse && !actor.Drafted && !actor.InMentalState && !curJob.playerForced && actor.HostileTo(curJob.GetTarget(target).Thing) && (!actor.IsMutant || !actor.mutant.Def.canBeDrafted))
				{
					MoteMaker.MakeColonistActionOverlay(actor, ThingDefOf.Mote_ColonistAttacking);
				}
			};
			return toil;
		}

		public static Toil FindRandomAdjacentReachableCell(TargetIndex adjacentToInd, TargetIndex cellInd)
		{
			Toil findCell = ToilMaker.MakeToil("FindRandomAdjacentReachableCell");
			findCell.initAction = delegate
			{
				Pawn actor = findCell.actor;
				Job curJob = actor.CurJob;
				LocalTargetInfo target = curJob.GetTarget(adjacentToInd);
				if (target.HasThing && (!target.Thing.Spawned || target.Thing.Map != actor.Map))
				{
					string obj = actor?.ToString();
					LocalTargetInfo localTargetInfo = target;
					Log.Error(obj + " could not find standable cell adjacent to " + localTargetInfo.ToString() + " because this thing is either unspawned or spawned somewhere else.");
					actor.jobs.curDriver.EndJobWith(JobCondition.Errored);
				}
				else
				{
					int num = 0;
					IntVec3 intVec;
					do
					{
						num++;
						if (num > 100)
						{
							string obj2 = actor?.ToString();
							LocalTargetInfo localTargetInfo = target;
							Log.Error(obj2 + " could not find standable cell adjacent to " + localTargetInfo.ToString());
							actor.jobs.curDriver.EndJobWith(JobCondition.Errored);
							return;
						}
						intVec = ((!target.HasThing) ? target.Cell.RandomAdjacentCell8Way() : target.Thing.RandomAdjacentCell8Way());
					}
					while (!intVec.Standable(actor.Map) || !actor.CanReserve(intVec) || !actor.CanReach(intVec, PathEndMode.OnCell, Danger.Deadly));
					curJob.SetTarget(cellInd, intVec);
				}
			};
			return findCell;
		}
	}
	public class Toils_Refuel
	{
		public static Toil FinalizeRefueling(TargetIndex refuelableInd, TargetIndex fuelInd)
		{
			Toil toil = ToilMaker.MakeToil("FinalizeRefueling");
			toil.initAction = delegate
			{
				Job curJob = toil.actor.CurJob;
				Thing thing = curJob.GetTarget(refuelableInd).Thing;
				if (toil.actor.CurJob.placedThings.NullOrEmpty())
				{
					thing.TryGetComp<CompRefuelable>().Refuel(new List<Thing> { curJob.GetTarget(fuelInd).Thing });
				}
				else
				{
					thing.TryGetComp<CompRefuelable>().Refuel(toil.actor.CurJob.placedThings.Select((ThingCountClass p) => p.thing).ToList());
				}
			};
			toil.defaultCompleteMode = ToilCompleteMode.Instant;
			return toil;
		}
	}
	public class JobDriver_ExtractTree : JobDriver
	{
		private float workLeft;

		private float totalNeededWork;

		public const TargetIndex TreeInd = TargetIndex.A;

		protected Thing Target => job.GetTarget(TargetIndex.A).Thing;

		protected Plant Tree => (Plant)Target.GetInnerIfMinified();

		protected DesignationDef Designation => DesignationDefOf.ExtractTree;

		protected float TotalNeededWork => Tree.def.plant.harvestWork;

		public override void ExposeData()
		{
			base.ExposeData();
			Scribe_Values.Look(ref workLeft, "workLeft", 0f);
			Scribe_Values.Look(ref totalNeededWork, "totalNeededWork", 0f);
		}

		public override bool TryMakePreToilReservations(bool errorOnFailed)
		{
			return pawn.Reserve(Target, job, 1, -1, null, errorOnFailed);
		}

		protected override IEnumerable<Toil> MakeNewToils()
		{
			this.FailOnThingMissingDesignation(TargetIndex.A, Designation);
			this.FailOnForbidden(TargetIndex.A);
			yield return Toils_Goto.GotoThing(TargetIndex.A, PathEndMode.Touch);
			Toil doWork = ToilMaker.MakeToil("MakeNewToils").FailOnDestroyedNullOrForbidden(TargetIndex.A).FailOnCannotTouch(TargetIndex.A, PathEndMode.Touch);
			doWork.initAction = delegate
			{
				totalNeededWork = TotalNeededWork;
				workLeft = totalNeededWork;
			};
			doWork.tickIntervalAction = delegate(int delta)
			{
				workLeft -= JobDriver_PlantWork.WorkDonePerTick(pawn, Tree) * (float)delta;
				if (pawn.skills != null)
				{
					pawn.skills.Learn(SkillDefOf.Plants, 0.085f * (float)delta);
				}
				if (workLeft <= 0f)
				{
					SoundDefOf.Finish_Wood.PlayOneShot(SoundInfo.InMap(Tree));
					doWork.actor.jobs.curDriver.ReadyForNextToil();
				}
			};
			doWork.defaultCompleteMode = ToilCompleteMode.Never;
			doWork.WithProgressBar(TargetIndex.A, () => 1f - workLeft / totalNeededWork);
			doWork.WithEffect(EffecterDefOf.Harvest_Plant, TargetIndex.A);
			doWork.PlaySustainerOrSound(() => SoundDefOf.Interact_ConstructDirt);
			doWork.activeSkill = () => SkillDefOf.Plants;
			yield return doWork;
			Toil toil = ToilMaker.MakeToil("MakeNewToils");
			toil.initAction = delegate
			{
				IntVec3 position = Tree.Position;
				bool num = Find.Selector.IsSelected(Tree);
				Thing thing = GenSpawn.Spawn(Tree.MakeMinified(), position, pawn.Map);
				if (num && thing != null)
				{
					Find.Selector.Select(thing, playSound: false, forceDesignatorDeselect: false);
				}
				base.Map.designationManager.RemoveAllDesignationsOn(Target);
			};
			toil.defaultCompleteMode = ToilCompleteMode.Instant;
			yield return toil;
		}
	}
	public class JobDriver_PlantSeed : JobDriver
	{
		private float sowWorkDone;

		private const TargetIndex SeedIndex = TargetIndex.A;

		private const TargetIndex PlantCellIndex = TargetIndex.B;

		private const TargetIndex OldSeedStackIndex = TargetIndex.C;

		private IntVec3 PlantCell => job.GetTarget(TargetIndex.B).Cell;

		private CompPlantable PlantableComp => job.GetTarget(TargetIndex.A).Thing.TryGetComp<CompPlantable>();

		public override bool TryMakePreToilReservations(bool errorOnFailed)
		{
			return pawn.Reserve(job.targetA, job, 1, 1, null, errorOnFailed);
		}

		protected override IEnumerable<Toil> MakeNewToils()
		{
			this.FailOn(() => PlantUtility.AdjacentSowBlocker(job.plantDefToSow, PlantCell, base.Map) != null || !job.plantDefToSow.CanEverPlantAt(PlantCell, base.Map, canWipePlantsExceptTree: false, checkMapTemperature: false) || !PlantableComp.PlantCells.Contains(PlantCell));
			yield return Toils_Goto.GotoThing(TargetIndex.A, PathEndMode.Touch);
			yield return Toils_General.Do(delegate
			{
				LocalTargetInfo target = job.GetTarget(TargetIndex.A);
				if (target.HasThing && target.Thing.stackCount > job.count)
				{
					job.SetTarget(TargetIndex.C, target.Thing);
				}
			});
			yield return Toils_Haul.StartCarryThing(TargetIndex.A);
			yield return Toils_General.Do(delegate
			{
				LocalTargetInfo target = job.GetTarget(TargetIndex.C);
				if (target.IsValid && target.HasThing)
				{
					target.Thing.TryGetComp<CompPlantable>()?.Notify_SeedRemovedFromStackForPlantingAt(PlantCell);
				}
				PlantableComp?.Notify_RemovedFromStackForPlantingAt(PlantCell);
			});
			yield return Toils_Haul.CarryHauledThingToCell(TargetIndex.B, PathEndMode.Touch);
			Toil toil = ToilMaker.MakeToil("MakeNewToils");
			toil.tickIntervalAction = delegate(int delta)
			{
				sowWorkDone += pawn.GetStatValue(StatDefOf.PlantWorkSpeed) * (float)delta;
				if (pawn.skills != null)
				{
					pawn.skills.Learn(SkillDefOf.Plants, 0.085f * (float)delta);
				}
				if (sowWorkDone >= job.plantDefToSow.plant.sowWork)
				{
					ReadyForNextToil();
				}
			};
			toil.defaultCompleteMode = ToilCompleteMode.Never;
			toil.WithEffect(EffecterDefOf.Sow, TargetIndex.B);
			toil.PlaySustainerOrSound(() => SoundDefOf.Interact_Sow);
			toil.WithProgressBar(TargetIndex.B, () => sowWorkDone / job.plantDefToSow.plant.sowWork, interpolateBetweenActorAndTarget: true);
			toil.activeSkill = () => SkillDefOf.Plants;
			yield return toil;
			yield return Toils_General.Do(delegate
			{
				PlantableComp.DoPlant(pawn, PlantCell, pawn.Map);
			});
		}

		public override void ExposeData()
		{
			base.ExposeData();
			Scribe_Values.Look(ref sowWorkDone, "sowWorkDone", 0f);
		}
	}
	public class JobDriver_PlantSow : JobDriver
	{
		private float sowWorkDone;

		private Plant Plant => (Plant)job.GetTarget(TargetIndex.A).Thing;

		public override void ExposeData()
		{
			base.ExposeData();
			Scribe_Values.Look(ref sowWorkDone, "sowWorkDone", 0f);
		}

		public override bool TryMakePreToilReservations(bool errorOnFailed)
		{
			return pawn.Reserve(job.targetA, job, 1, -1, null, errorOnFailed);
		}

		protected override IEnumerable<Toil> MakeNewToils()
		{
			yield return Toils_Goto.GotoCell(TargetIndex.A, PathEndMode.Touch).FailOn(() => PlantUtility.AdjacentSowBlocker(job.plantDefToSow, base.TargetA.Cell, base.Map) != null).FailOn(() => !job.plantDefToSow.CanNowPlantAt(base.TargetLocA, base.Map))
				.FailOn((Func<bool>)delegate
				{
					List<Thing> thingList = base.TargetA.Cell.GetThingList(base.Map);
					for (int i = 0; i < thingList.Count; i++)
					{
						if (thingList[i].def == job.plantDefToSow)
						{
							return true;
						}
					}
					return false;
				});
			Toil sowToil = ToilMaker.MakeToil("MakeNewToils");
			sowToil.initAction = delegate
			{
				base.TargetThingA = GenSpawn.Spawn(job.plantDefToSow, base.TargetLocA, base.Map);
				pawn.Reserve(base.TargetThingA, sowToil.actor.CurJob);
				Plant plant = Plant;
				plant.Growth = 0f;
				plant.sown = true;
			};
			sowToil.tickIntervalAction = delegate(int delta)
			{
				Pawn actor = sowToil.actor;
				actor.skills?.Learn(SkillDefOf.Plants, 0.085f * (float)delta);
				Plant plant = Plant;
				if (plant.LifeStage != PlantLifeStage.Sowing)
				{
					Log.Error($"{this} getting sowing work while not in Sowing life stage.");
				}
				sowWorkDone += actor.GetStatValue(StatDefOf.PlantWorkSpeed) * (float)delta;
				if (!(sowWorkDone < plant.def.plant.sowWork))
				{
					plant.Growth = 0.0001f;
					base.Map.mapDrawer.MapMeshDirty(plant.Position, MapMeshFlagDefOf.Things);
					actor.records.Increment(RecordDefOf.PlantsSown);
					Find.HistoryEventsManager.RecordEvent(new HistoryEvent(HistoryEventDefOf.SowedPlant, actor.Named(HistoryEventArgsNames.Doer)));
					if (plant.def.plant.humanFoodPlant)
					{
						Find.HistoryEventsManager.RecordEvent(new HistoryEvent(HistoryEventDefOf.SowedHumanFoodPlant, actor.Named(HistoryEventArgsNames.Doer)));
					}
					ReadyForNextToil();
				}
			};
			sowToil.defaultCompleteMode = ToilCompleteMode.Never;
			sowToil.FailOnDespawnedNullOrForbidden(TargetIndex.A);
			sowToil.FailOnCannotTouch(TargetIndex.A, PathEndMode.Touch);
			sowToil.WithEffect(EffecterDefOf.Sow, TargetIndex.A);
			sowToil.WithProgressBar(TargetIndex.A, () => sowWorkDone / Plant.def.plant.sowWork, interpolateBetweenActorAndTarget: true);
			sowToil.PlaySustainerOrSound(() => SoundDefOf.Interact_Sow);
			sowToil.AddFinishAction(delegate
			{
				if (base.TargetThingA != null)
				{
					Plant plant = (Plant)sowToil.actor.CurJob.GetTarget(TargetIndex.A).Thing;
					if (sowWorkDone < plant.def.plant.sowWork && !base.TargetThingA.Destroyed)
					{
						base.TargetThingA.Destroy();
					}
				}
			});
			sowToil.activeSkill = () => SkillDefOf.Plants;
			yield return sowToil;
		}
	}
	public abstract class JobDriver_PlantWork : JobDriver
	{
		private float workDone;

		protected float xpPerTick;

		protected const TargetIndex PlantInd = TargetIndex.A;

		protected Plant Plant => (Plant)job.targetA.Thing;

		protected virtual DesignationDef RequiredDesignation => null;

		protected virtual PlantDestructionMode PlantDestructionMode => PlantDestructionMode.Smash;

		public static float WorkDonePerTick(Pawn actor, Plant plant)
		{
			return actor.GetStatValue(StatDefOf.PlantWorkSpeed) * Mathf.Lerp(3.3f, 1f, plant.Growth);
		}

		public override bool TryMakePreToilReservations(bool errorOnFailed)
		{
			LocalTargetInfo target = job.GetTarget(TargetIndex.A);
			if (target.IsValid && !pawn.Reserve(target, job, 1, -1, null, errorOnFailed))
			{
				return false;
			}
			pawn.ReserveAsManyAsPossible(job.GetTargetQueue(TargetIndex.A), job);
			return true;
		}

		protected override IEnumerable<Toil> MakeNewToils()
		{
			Init();
			yield return Toils_JobTransforms.MoveCurrentTargetIntoQueue(TargetIndex.A);
			Toil initExtractTargetFromQueue = Toils_JobTransforms.ClearDespawnedNullOrForbiddenQueuedTargets(TargetIndex.A, (RequiredDesignation != null) ? ((Func<Thing, bool>)((Thing t) => base.Map.designationManager.DesignationOn(t, RequiredDesignation) != null)) : null);
			yield return initExtractTargetFromQueue;
			yield return Toils_JobTransforms.SucceedOnNoTargetInQueue(TargetIndex.A);
			yield return Toils_JobTransforms.ExtractNextTargetFromQueue(TargetIndex.A);
			Toil toil = Toils_Goto.GotoThing(TargetIndex.A, PathEndMode.Touch).JumpIfDespawnedOrNullOrForbidden(TargetIndex.A, initExtractTargetFromQueue);
			if (RequiredDesignation != null)
			{
				toil.FailOnThingMissingDesignation(TargetIndex.A, RequiredDesignation);
			}
			yield return toil;
			Toil cut = ToilMaker.MakeToil("MakeNewToils");
			cut.tickIntervalAction = delegate(int delta)
			{
				//IL_010e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0114: Unknown result type (might be due to invalid IL or missing references)
				//IL_0119: Unknown result type (might be due to invalid IL or missing references)
				//IL_0123: Unknown result type (might be due to invalid IL or missing references)
				Pawn actor = cut.actor;
				if (actor.skills != null)
				{
					actor.skills.Learn(SkillDefOf.Plants, xpPerTick * (float)delta);
				}
				Plant plant = Plant;
				workDone += WorkDonePerTick(actor, plant) * (float)delta;
				if (!(workDone < plant.def.plant.harvestWork))
				{
					if (plant.def.plant.harvestedThingDef != null)
					{
						StatDef stat = ((plant.def.plant.harvestedThingDef.IsDrug || plant.def.plant.drugForHarvestPurposes) ? StatDefOf.DrugHarvestYield : StatDefOf.PlantHarvestYield);
						float statValue = actor.GetStatValue(stat);
						if (actor.RaceProps.Humanlike && plant.def.plant.harvestFailable && !plant.Blighted && Rand.Value > statValue)
						{
							MoteMaker.ThrowText((pawn.DrawPos + plant.DrawPos) / 2f, base.Map, "TextMote_HarvestFailed".Translate(), 3.65f);
						}
						else
						{
							int num = plant.YieldNow();
							if (statValue > 1f)
							{
								num = GenMath.RoundRandom((float)num * statValue);
							}
							if (num > 0)
							{
								Thing thing = ThingMaker.MakeThing(plant.def.plant.harvestedThingDef);
								thing.stackCount = num;
								if (actor.Faction != Faction.OfPlayer)
								{
									thing.SetForbidden(value: true);
								}
								Find.QuestManager.Notify_PlantHarvested(actor, thing);
								GenPlace.TryPlaceThing(thing, actor.Position, base.Map, ThingPlaceMode.Near);
								actor.records.Increment(RecordDefOf.PlantsHarvested);
							}
							if (plant.HarvestableNow)
							{
								foreach (ThingComp allComp in plant.AllComps)
								{
									foreach (ThingDefCountClass item in allComp.GetAdditionalHarvestYield())
									{
										Thing thing2 = ThingMaker.MakeThing(item.thingDef);
										thing2.stackCount = item.count;
										GenPlace.TryPlaceThing(thing2, actor.Position, base.Map, ThingPlaceMode.Near);
									}
								}
							}
						}
					}
					plant.def.plant.soundHarvestFinish.PlayOneShot(actor);
					plant.PlantCollected(pawn, PlantDestructionMode);
					workDone = 0f;
					ReadyForNextToil();
				}
			};
			cut.FailOnDespawnedNullOrForbidden(TargetIndex.A);
			if (RequiredDesignation != null)
			{
				cut.FailOnThingMissingDesignation(TargetIndex.A, RequiredDesignation);
			}
			cut.FailOnCannotTouch(TargetIndex.A, PathEndMode.Touch);
			cut.defaultCompleteMode = ToilCompleteMode.Never;
			cut.WithEffect((Plant?.def.plant.IsTree ?? false) ? EffecterDefOf.Harvest_Tree : EffecterDefOf.Harvest_Plant, TargetIndex.A);
			cut.WithProgressBar(TargetIndex.A, () => workDone / Plant.def.plant.harvestWork, interpolateBetweenActorAndTarget: true);
			cut.PlaySustainerOrSound(() => Plant.def.plant.soundHarvesting);
			cut.activeSkill = () => SkillDefOf.Plants;
			yield return cut;
			Toil toil2 = PlantWorkDoneToil();
			if (toil2 != null)
			{
				yield return toil2;
			}
			yield return Toils_Jump.Jump(initExtractTargetFromQueue);
		}

		public override void ExposeData()
		{
			base.ExposeData();
			Scribe_Values.Look(ref workDone, "workDone", 0f);
		}

		protected virtual void Init()
		{
		}

		protected virtual Toil PlantWorkDoneToil()
		{
			return null;
		}
	}
	public class JobDriver_PlantHarvest : JobDriver_PlantWork
	{
		protected override PlantDestructionMode PlantDestructionMode => PlantDestructionMode.Chop;

		protected override void Init()
		{
			xpPerTick = 0.085f;
		}

		protected override Toil PlantWorkDoneToil()
		{
			return Toils_General.RemoveDesignationsOnThing(TargetIndex.A, DesignationDefOf.HarvestPlant);
		}
	}
